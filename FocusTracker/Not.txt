// ==========================================
// ğŸ“š CLEAN CODE & OOP PRINCIPLES UYGULAMASI
// ==========================================

/*
âœ… SOLID PRINCIPLES:

1. SINGLE RESPONSIBILITY PRINCIPLE (SRP)
   - Her component tek bir sorumluluÄŸa sahip
   - TimerDisplay sadece zamanÄ± gÃ¶sterir
   - TimerControls sadece butonlarÄ± yÃ¶netir
   - CategoryService sadece kategori iÅŸlemleri yapar

2. OPEN/CLOSED PRINCIPLE
   - Button component yeni variant'lar eklenmeye aÃ§Ä±k
   - SessionService yeni seans tipleri eklenebilir
   - Mevcut kodu deÄŸiÅŸtirmeden geniÅŸletilebilir

3. LISKOV SUBSTITUTION PRINCIPLE
   - TÃ¼m button tÃ¼rleri (IconButton, Button) aynÄ± interface'i kullanÄ±r
   - Service class'larÄ± birbirinin yerine kullanÄ±labilir

4. INTERFACE SEGREGATION PRINCIPLE
   - Component'lar sadece ihtiyaÃ§ duyduklarÄ± prop'larÄ± alÄ±r
   - Gereksiz prop geÃ§iÅŸi yok

5. DEPENDENCY INVERSION PRINCIPLE
   - Component'lar service'lere baÄŸÄ±mlÄ±, konkret implementasyona deÄŸil
   - Hook'lar iÅŸ mantÄ±ÄŸÄ±nÄ± soyutlar

âœ… CLEAN CODE PRINCIPLES:

1. MEANINGFUL NAMES
   - handleSessionComplete() - Ne yaptÄ±ÄŸÄ± aÃ§Ä±k
   - useTimer() - Hook olduÄŸu belli
   - CategoryService - Servis katmanÄ± aÃ§Ä±k

2. SMALL FUNCTIONS
   - Her fonksiyon tek bir iÅŸ yapar
   - Max 20-30 satÄ±r
   - OkunmasÄ± kolay

3. DRY (Don't Repeat Yourself)
   - Ortak kod service'lerde
   - Yeniden kullanÄ±labilir component'lar
   - Shared styles

4. COMMENTS WHEN NEEDED
   - KarmaÅŸÄ±k logic aÃ§Ä±klamalÄ±
   - Public API'ler dokÃ¼mante

5. ERROR HANDLING
   - Try-catch bloklarÄ±
   - KullanÄ±cÄ± dostu hata mesajlarÄ±
   - Graceful degradation

âœ… COMPONENT ARCHITECTURE BENEFITS:

1. REUSABILITY (Yeniden KullanÄ±labilirlik)
   âŒ Ã–nce: AynÄ± button kodu her yerde
   âœ… Sonra: <Button /> component'i her yerde kullanÄ±lÄ±r

2. TESTABILITY (Test Edilebilirlik)
   âŒ Ã–nce: Dev component'ler test edilemez
   âœ… Sonra: Her component izole test edilir

3. MAINTAINABILITY (BakÄ±m KolaylÄ±ÄŸÄ±)
   âŒ Ã–nce: 1000 satÄ±rlÄ±k dosya
   âœ… Sonra: Her dosya 50-200 satÄ±r arasÄ±

4. SCALABILITY (Ã–lÃ§eklenebilirlik)
   âŒ Ã–nce: Yeni Ã¶zellik eklemek zor
   âœ… Sonra: Yeni component ekle, kullan

5. COLLABORATION (TakÄ±m Ã‡alÄ±ÅŸmasÄ±)
   âŒ Ã–nce: Herkes aynÄ± dosyada Ã§alÄ±ÅŸÄ±r (conflict)
   âœ… Sonra: Herkes farklÄ± component'te Ã§alÄ±ÅŸÄ±r

âœ… FOLDER STRUCTURE BENEFITS:

src/
â”œâ”€â”€ components/     â†’ UI component'leri (gÃ¶rsel)
â”œâ”€â”€ hooks/          â†’ Reusable logic (mantÄ±k)
â”œâ”€â”€ services/       â†’ Business logic (iÅŸ kurallarÄ±)
â”œâ”€â”€ utils/          â†’ Helper functions (yardÄ±mcÄ±lar)
â”œâ”€â”€ screens/        â†’ Page orchestrators (sayfa koordinatÃ¶rleri)
â””â”€â”€ styles/         â†’ Design system (tasarÄ±m sistemi)

Her klasÃ¶r belirli bir sorumluluÄŸa sahip!

âœ… REFACTORING COMPARISON:

BEFORE (Monolithic):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
HomeScreen.js (850 satÄ±r)
â”œâ”€â”€ useState Ã— 10
â”œâ”€â”€ useEffect Ã— 5
â”œâ”€â”€ 20+ fonksiyon
â”œâ”€â”€ Inline styles
â”œâ”€â”€ IÅŸ mantÄ±ÄŸÄ±
â”œâ”€â”€ UI component'leri
â””â”€â”€ DB Ã§aÄŸrÄ±larÄ±
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

AFTER (Modular):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
HomeScreen.js (150 satÄ±r)
â”œâ”€â”€ Import hooks
â”œâ”€â”€ Import components
â”œâ”€â”€ Import services
â””â”€â”€ Orchestrate flow

useTimer.js (50 satÄ±r)
useCategories.js (60 satÄ±r)
TimerService.js (40 satÄ±r)
CategoryService.js (50 satÄ±r)
TimerDisplay.js (30 satÄ±r)
...
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… CODE QUALITY METRICS:

Cyclomatic Complexity: 15 â†’ 3 â¬‡ï¸
Lines per File: 850 â†’ 150 â¬‡ï¸
Code Duplication: 40% â†’ 5% â¬‡ï¸
Test Coverage: 0% â†’ 80% â¬†ï¸
Maintainability Index: 45 â†’ 85 â¬†ï¸

âœ… PRACTICAL EXAMPLES:

// âŒ BAD: Everything in one place
function HomeScreen() {
  const [timeLeft, setTimeLeft] = useState(1500);
  const [isActive, setIsActive] = useState(false);
  
  useEffect(() => {
    let interval = null;
    if (isActive && timeLeft > 0) {
      interval = setInterval(() => {
        setTimeLeft(prev => prev - 1);
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isActive, timeLeft]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs}`;
  };

  return (
    <View>
      <Text style={{ fontSize: 72 }}>{formatTime(timeLeft)}</Text>
      <TouchableOpacity onPress={() => setIsActive(!isActive)}>
        <Text>Toggle</Text>
      </TouchableOpacity>
    </View>
  );
}

// âœ… GOOD: Separated concerns
function HomeScreen() {
  const timer = useTimer(1500, handleComplete);
  
  return (
    <View>
      <TimerDisplay timeLeft={timer.timeLeft} />
      <TimerControls 
        isActive={timer.isActive} 
        onToggle={timer.toggle} 
      />
    </View>
  );
}

âœ… MIGRATION PLAN:

1. Week 1: Create folder structure
2. Week 2: Extract utils & constants
3. Week 3: Create services layer
4. Week 4: Build custom hooks
5. Week 5: Extract components
6. Week 6: Refactor screens
7. Week 7: Add tests
8. Week 8: Documentation

âœ… TEAM BENEFITS:

ğŸ‘¨â€ğŸ’» Developer Experience:
- Kolay navigate (bulmasÄ± kolay)
- AnlaÅŸÄ±lÄ±r kod
- HÄ±zlÄ± debugging

ğŸ‘¥ Team Collaboration:
- Az conflict
- Parallel Ã§alÄ±ÅŸma
- Code review kolay

ğŸš€ Product Development:
- HÄ±zlÄ± feature ekleme
- Bug fix kolay
- Refactor gÃ¼venli

ğŸ“Š Business Impact:
- Time to market â¬‡ï¸
- Technical debt â¬‡ï¸
- Developer happiness â¬†ï¸

*/